/*
 * st7565s_gfx.c
 *
 *  Created on: Nov 24, 2025
 *      Author: Zver
 */
#include "st7565s_gfx.h"
#include <string.h>

// Классический 5x7 ASCII (печатные 0x20..0x7E), столбцы, бит0 = верхний пиксель
static const uint8_t font5x7[95][5] = {
  {0x00,0x00,0x00,0x00,0x00}, // 0x20 ' '
  {0x00,0x00,0x5F,0x00,0x00}, // 0x21 '!'
  {0x00,0x07,0x00,0x07,0x00}, // 0x22 '"'
  {0x14,0x7F,0x14,0x7F,0x14}, // 0x23 '#'
  {0x24,0x2A,0x7F,0x2A,0x12}, // 0x24 '$'
  {0x23,0x13,0x08,0x64,0x62}, // 0x25 '%'
  {0x36,0x49,0x55,0x22,0x50}, // 0x26 '&'
  {0x00,0x05,0x03,0x00,0x00}, // 0x27 '''
  {0x00,0x1C,0x22,0x41,0x00}, // 0x28 '('
  {0x00,0x41,0x22,0x1C,0x00}, // 0x29 ')'
  {0x14,0x08,0x3E,0x08,0x14}, // 0x2A '*'
  {0x08,0x08,0x3E,0x08,0x08}, // 0x2B '+'
  {0x00,0x50,0x30,0x00,0x00}, // 0x2C ','
  {0x08,0x08,0x08,0x08,0x08}, // 0x2D '-'
  {0x00,0x60,0x60,0x00,0x00}, // 0x2E '.'
  {0x20,0x10,0x08,0x04,0x02}, // 0x2F '/'

  {0x3E,0x51,0x49,0x45,0x3E}, // 0x30 '0'
  {0x00,0x42,0x7F,0x40,0x00}, // 0x31 '1'
  {0x42,0x61,0x51,0x49,0x46}, // 0x32 '2'
  {0x21,0x41,0x45,0x4B,0x31}, // 0x33 '3'
  {0x18,0x14,0x12,0x7F,0x10}, // 0x34 '4'
  {0x27,0x45,0x45,0x45,0x39}, // 0x35 '5'
  {0x3C,0x4A,0x49,0x49,0x30}, // 0x36 '6'
  {0x01,0x71,0x09,0x05,0x03}, // 0x37 '7'
  {0x36,0x49,0x49,0x49,0x36}, // 0x38 '8'
  {0x06,0x49,0x49,0x29,0x1E}, // 0x39 '9'
  {0x00,0x36,0x36,0x00,0x00}, // 0x3A ':'
  {0x00,0x56,0x36,0x00,0x00}, // 0x3B ';'
  {0x08,0x14,0x22,0x41,0x00}, // 0x3C '<'
  {0x14,0x14,0x14,0x14,0x14}, // 0x3D '='
  {0x00,0x41,0x22,0x14,0x08}, // 0x3E '>'
  {0x02,0x01,0x51,0x09,0x06}, // 0x3F '?'

  {0x32,0x49,0x79,0x41,0x3E}, // 0x40 '@'
  {0x7E,0x11,0x11,0x11,0x7E}, // 0x41 'A'
  {0x7F,0x49,0x49,0x49,0x36}, // 0x42 'B'
  {0x3E,0x41,0x41,0x41,0x22}, // 0x43 'C'
  {0x7F,0x41,0x41,0x22,0x1C}, // 0x44 'D'
  {0x7F,0x49,0x49,0x49,0x41}, // 0x45 'E'
  {0x7F,0x09,0x09,0x09,0x01}, // 0x46 'F'
  {0x3E,0x41,0x49,0x49,0x7A}, // 0x47 'G'
  {0x7F,0x08,0x08,0x08,0x7F}, // 0x48 'H'
  {0x00,0x41,0x7F,0x41,0x00}, // 0x49 'I'
  {0x20,0x40,0x41,0x3F,0x01}, // 0x4A 'J'
  {0x7F,0x08,0x14,0x22,0x41}, // 0x4B 'K'
  {0x7F,0x40,0x40,0x40,0x40}, // 0x4C 'L'
  {0x7F,0x02,0x0C,0x02,0x7F}, // 0x4D 'M'
  {0x7F,0x04,0x08,0x10,0x7F}, // 0x4E 'N'
  {0x3E,0x41,0x41,0x41,0x3E}, // 0x4F 'O'

  {0x7F,0x09,0x09,0x09,0x06}, // 0x50 'P'
  {0x3E,0x41,0x51,0x21,0x5E}, // 0x51 'Q'
  {0x7F,0x09,0x19,0x29,0x46}, // 0x52 'R'
  {0x46,0x49,0x49,0x49,0x31}, // 0x53 'S'
  {0x01,0x01,0x7F,0x01,0x01}, // 0x54 'T'
  {0x3F,0x40,0x40,0x40,0x3F}, // 0x55 'U'
  {0x1F,0x20,0x40,0x20,0x1F}, // 0x56 'V'
  {0x7F,0x20,0x18,0x20,0x7F}, // 0x57 'W'
  {0x63,0x14,0x08,0x14,0x63}, // 0x58 'X'
  {0x03,0x04,0x78,0x04,0x03}, // 0x59 'Y'
  {0x61,0x51,0x49,0x45,0x43}, // 0x5A 'Z'
  {0x00,0x7F,0x41,0x41,0x00}, // 0x5B '['
  {0x02,0x04,0x08,0x10,0x20}, // 0x5C '\'
  {0x00,0x41,0x41,0x7F,0x00}, // 0x5D ']'
  {0x04,0x02,0x01,0x02,0x04}, // 0x5E '^'
  {0x80,0x80,0x80,0x80,0x80}, // 0x5F '_'

  {0x00,0x03,0x05,0x00,0x00}, // 0x60 '`'
  {0x20,0x54,0x54,0x54,0x78}, // 0x61 'a'
  {0x7F,0x48,0x44,0x44,0x38}, // 0x62 'b'
  {0x38,0x44,0x44,0x44,0x20}, // 0x63 'c'
  {0x38,0x44,0x44,0x48,0x7F}, // 0x64 'd'
  {0x38,0x54,0x54,0x54,0x18}, // 0x65 'e'
  {0x08,0x7E,0x09,0x01,0x02}, // 0x66 'f'
  {0x0C,0x52,0x52,0x52,0x3E}, // 0x67 'g'
  {0x7F,0x08,0x04,0x04,0x78}, // 0x68 'h'
  {0x00,0x44,0x7D,0x40,0x00}, // 0x69 'i'
  {0x20,0x40,0x44,0x3D,0x00}, // 0x6A 'j'
  {0x7F,0x10,0x28,0x44,0x00}, // 0x6B 'k'
  {0x00,0x41,0x7F,0x40,0x00}, // 0x6C 'l'
  {0x7C,0x04,0x18,0x04,0x78}, // 0x6D 'm'
  {0x7C,0x08,0x04,0x04,0x78}, // 0x6E 'n'
  {0x38,0x44,0x44,0x44,0x38}, // 0x6F 'o'

  {0x7C,0x14,0x14,0x14,0x08}, // 0x70 'p'
  {0x08,0x14,0x14,0x14,0x7C}, // 0x71 'q'
  {0x7C,0x08,0x04,0x04,0x08}, // 0x72 'r'
  {0x48,0x54,0x54,0x54,0x20}, // 0x73 's'
  {0x04,0x3F,0x44,0x40,0x20}, // 0x74 't'
  {0x3C,0x40,0x40,0x20,0x7C}, // 0x75 'u'
  {0x1C,0x20,0x40,0x20,0x1C}, // 0x76 'v'
  {0x3C,0x40,0x30,0x40,0x3C}, // 0x77 'w'
  {0x44,0x28,0x10,0x28,0x44}, // 0x78 'x'
  {0x0C,0x50,0x50,0x50,0x3C}, // 0x79 'y'
  {0x44,0x64,0x54,0x4C,0x44}, // 0x7A 'z'
  {0x00,0x08,0x36,0x41,0x00}, // 0x7B '{'
  {0x00,0x00,0x7F,0x00,0x00}, // 0x7C '|'
  {0x00,0x41,0x36,0x08,0x00}, // 0x7D '}'
  {0x10,0x08,0x08,0x10,0x08}, // 0x7E '~'
};

void GFX_DrawPixel(uint8_t* fb, int x, int y, bool color){
  if (!fb) return;
  if (x < 0 || y < 0 || x >= LCD_WIDTH || y >= LCD_HEIGHT) return;
  uint16_t idx = (y >> 3) * LCD_WIDTH + x;   // страница * ширина + колонка
  uint8_t  m   = 1u << (y & 7);
  if (color) fb[idx] |= m;
  else       fb[idx] &= (uint8_t)~m;
}

void GFX_DrawChar(uint8_t* fb, int x, int y, char c, bool color){
  if (c < 32 || c > 126) c = '?';
  const uint8_t* g = font5x7[(uint8_t)c - 32];

  // Столбцы 0..4
  for (int col = 0; col < 5; col++){
    uint8_t line = g[col];
    for (int row = 0; row < 7; row++){
      if (line & (1u << row)){
        GFX_DrawPixel(fb, x + col, y + row, color);
      }
    }
  }
  // Межсимвольный зазор 1px
  // Можно очистить фон: закомментируйте/раскомментируйте строку ниже при желании:
  // for (int row=0; row<7; row++) GFX_DrawPixel(fb, x+5, y+row, 0);
}

void GFX_DrawString(uint8_t* fb, int x, int y, const char* s, bool color){
  if (!s) return;
  int cx = x;
  while (*s){
    if (*s == '\n'){ cx = x; y += 8; s++; continue; }
    GFX_DrawChar(fb, cx, y, *s, color);
    cx += 6; // 5 ширина + 1 зазор
    s++;
  }
}

int GFX_TextWidth(const char* s, uint8_t scale){
  if (!s) return 0;
  int n = 0;
  for (const char* p = s; *p; ++p){
    if (*p == '\n') break;
    n++;
  }
  return n * 6 * (int)scale; // 5px символ + 1px зазор
}

void GFX_DrawCharScaled(uint8_t* fb, int x, int y, char c, bool color, uint8_t scale){
  if (scale <= 1){ GFX_DrawChar(fb, x, y, c, color); return; }
  if (c < 32 || c > 126) c = '?';
  extern const uint8_t font5x7[95][5]; // объявление шрифта
  const uint8_t* g = font5x7[(uint8_t)c - 32];

  for (int col = 0; col < 5; col++){
    uint8_t line = g[col];
    for (int row = 0; row < 7; row++){
      if (line & (1u << row)){
        // масштабируем пиксель в блок scale x scale
        for (int dy = 0; dy < scale; dy++){
          for (int dx = 0; dx < scale; dx++){
            GFX_DrawPixel(fb, x + col*scale + dx, y + row*scale + dy, color);
          }
        }
      }
    }
  }
}

void GFX_DrawStringScaled(uint8_t* fb, int x, int y, const char* s, bool color, uint8_t scale){
  if (!s) return;
  int cx = x;
  while (*s){
    if (*s == '\n'){ cx = x; y += (8 * scale); s++; continue; }
    GFX_DrawCharScaled(fb, cx, y, *s, color, scale);
    cx += (6 * scale); // 5px + 1px зазор, умноженное на scale
    s++;
  }
}

// ---- Доп. 6x8 глифы кириллицы (ВЕРХНИЙ РЕГИСТР) ----
// bit0 в каждом байте = верхний пиксель, 6 столбцов слева направо
static const uint8_t RU_P_CAP[6]   = {0x7F,0x01,0x01,0x01,0x7F,0x00}; // П
static const uint8_t RU_CH_CAP[6]  = {0x07,0x08,0x08,0x08,0x7F,0x00}; // Ч
static const uint8_t RU_YA_CAP[6]  = {0x46,0x29,0x19,0x09,0x7F,0x00}; // Я
static const uint8_t RU_L_CAP[6]   = {0x40,0x20,0x1F,0x01,0x7F,0x00}; // Л (приближенно)
static const uint8_t RU_G_CAP[6]   = {0x7F,0x01,0x01,0x01,0x01,0x00}; // Г
static const uint8_t RU_TS_CAP[6]  = {0x7F,0x40,0x40,0x40,0x7F,0xC0}; // Ц (с "хвостиком" снизу)
static const uint8_t RU_D_CAP[6]   = {0xC0,0x7F,0x41,0x41,0x7F,0xC0}; // Д: нижняя «юбка» + верхняя перекладина
static const uint8_t RU_I_CAP[6]   = {0x7F,0x10,0x08,0x04,0x7F,0x00}; // И: вертикали + диагональ
static const uint8_t RU_SOFT_CAP[6]= {0x7F,0x48,0x48,0x48,0x30,0x00}; // Ь: нижняя «чашка»
static const uint8_t RU_U_CAP[6]   = {0x07,0x48,0x48,0x48,0x3F,0x00}; // У (U+0423): левая диагональ + правая стойка, короткий «хвостик» слева внизу
static const uint8_t RU_BE_CAP[6]  = {0x7F,0x49,0x49,0x49,0x39,0x00}; // Б (U+0411): левая стойка + верхняя полка и «пузико»


// Быстрый 6x8 рендер (масштаб)
void GFX_DrawGlyph6x8(uint8_t* fb, int x, int y, const uint8_t col[6], bool color, uint8_t scale){
  if (!fb || !col) return;
  if (scale <= 1){
    for (int cx=0; cx<6; ++cx){
      uint8_t bits = col[cx];
      for (int ry=0; ry<8; ++ry) if (bits & (1u<<ry)) GFX_DrawPixel(fb, x+cx, y+ry, color);
    }
  }else{
    for (int cx=0; cx<6; ++cx){
      uint8_t bits = col[cx];
      for (int ry=0; ry<8; ++ry) if (bits & (1u<<ry))
        for (int dy=0; dy<scale; ++dy)
          for (int dx=0; dx<scale; ++dx)
            GFX_DrawPixel(fb, x + cx*scale + dx, y + ry*scale + dy, color);
    }
  }
}

// Простейший декодер UTF-8: ASCII + кириллица (двухбайтовые D0/D1)
static const char* utf8_next(const char* s, uint32_t* cp){
  if (!s || !*s){ *cp = 0; return s; }
  const uint8_t *p = (const uint8_t*)s;
  if (*p < 0x80){ *cp = *p; return (const char*)(p+1); }
  if ((p[0] == 0xD0) || (p[0] == 0xD1)){
    uint8_t b1 = p[0], b2 = p[1];
    if (b2 >= 0x80 && b2 <= 0xBF){
      if (b1 == 0xD0) *cp = 0x0400 + (b2 - 0x80);
      else            *cp = 0x0440 + (b2 - 0x80);
      return (const char*)(p+2);
    }
  }
  *cp = '?'; return (const char*)(p+1);
}

// ASCII "похожие" глифы (возвращает ASCII-символ или 0)
static char ru_to_ascii_lookalike(uint32_t u){
  switch (u){
    // Верхний регистр
    case 0x0410: return 'A'; // А
    case 0x0412: return 'B'; // В
    case 0x0415: return 'E'; // Е
    case 0x041A: return 'K'; // К
    case 0x041C: return 'M'; // М
    case 0x041D: return 'H'; // Н
    case 0x041E: return 'O'; // О
    case 0x0420: return 'P'; // Р
    case 0x0421: return 'C'; // С
    case 0x0422: return 'T'; // Т
    case 0x0425: return 'X'; // Х
    case 0x0423: return 'Y'; // У ≈ Y
    case 0x0411: return 'B'; // Б ~ B (приближенно)
    // Нижний регистр — если пригодится позже
    case 0x0430: return 'a'; // а
    case 0x0435: return 'e'; // е
    case 0x043A: return 'k'; // к
    case 0x043C: return 'm'; // м
    case 0x043D: return 'h'; // н
    case 0x043E: return 'o'; // о
    case 0x0440: return 'p'; // р
    case 0x0441: return 'c'; // с
    case 0x0442: return 't'; // т
    case 0x0445: return 'x'; // х
    case 0x0443: return 'y'; // у
    case 0x0432: return 'b'; // в ~ b
    default: return 0;
  }
}

// Рисуем один RU-символ верхнего регистра нашими глифами (если есть)
static bool draw_ru_cap_custom(uint8_t* fb, int x, int y, uint32_t u, bool color, uint8_t scale){
  switch (u){
  	case 0x0414: GFX_DrawGlyph6x8(fb, x,y, RU_D_CAP,    color, scale); return true; // Д
    case 0x0418: GFX_DrawGlyph6x8(fb, x,y, RU_I_CAP,    color, scale); return true; // И
    case 0x042C: GFX_DrawGlyph6x8(fb, x,y, RU_SOFT_CAP, color, scale); return true; // Ь
    case 0x041F: GFX_DrawGlyph6x8(fb, x,y, RU_P_CAP,   color, scale); return true; // П
    case 0x0427: GFX_DrawGlyph6x8(fb, x,y, RU_CH_CAP,  color, scale); return true; // Ч
    case 0x0423: GFX_DrawGlyph6x8(fb, x,y, RU_U_CAP,   color, scale); return true; // У
    case 0x0411: GFX_DrawGlyph6x8(fb, x,y, RU_BE_CAP,  color, scale); return true; // Б
    case 0x042F: GFX_DrawGlyph6x8(fb, x,y, RU_YA_CAP,  color, scale); return true; // Я
    case 0x041B: GFX_DrawGlyph6x8(fb, x,y, RU_L_CAP,   color, scale); return true; // Л
    case 0x0413: GFX_DrawGlyph6x8(fb, x,y, RU_G_CAP,   color, scale); return true; // Г
    case 0x0426: GFX_DrawGlyph6x8(fb, x,y, RU_TS_CAP,  color, scale); return true; // Ц
    default: return false;
  }
}

// Рендер строки UTF-8 (ASCII + кириллица D0/D1)
void GFX_DrawStringUTF8_RU(uint8_t* fb, int x, int y, const char* utf8, bool color, uint8_t scale){
  if (!fb || !utf8) return;
  int cx = x;
  const char* p = utf8;
  while (*p){
    uint32_t u; const char* p2 = utf8_next(p, &u);
    if (!u) break;

    if (u == '\n'){ cx = x; y += 8*scale; p = p2; continue; }

    if (u < 128){
      if (scale <= 1) GFX_DrawChar(fb, cx, y, (char)u, color);
      else            GFX_DrawCharScaled(fb, cx, y, (char)u, color, scale);
      cx += 6*scale;
    } else {
      // Сначала пробуем кастомные ВЕРХНИЕ русские
      if (draw_ru_cap_custom(fb, cx, y, u, color, scale)){
        cx += 6*scale;
      } else {
        // Затем ASCII-похожие
        char a = ru_to_ascii_lookalike(u);
        if (a){
          if (scale <= 1) GFX_DrawChar(fb, cx, y, a, color);
          else            GFX_DrawCharScaled(fb, cx, y, a, color, scale);
          cx += 6*scale;
        } else {
          // Неизвестный символ
          if (scale <= 1) GFX_DrawChar(fb, cx, y, '?', color);
          else            GFX_DrawCharScaled(fb, cx, y, '?', color, scale);
          cx += 6*scale;
        }
      }
    }
    p = p2;
  }
}

int GFX_TextWidthUTF8_RU(const char* utf8, uint8_t scale){
  if (!utf8) return 0;
  int count = 0;
  const char* p = utf8;
  while (*p){
    uint32_t u; const char* p2 = utf8_next(p, &u);
    if (!u || u=='\n') break;
    (void)u; count++; p = p2;
  }
  return count * 6 * (int)scale;
}
